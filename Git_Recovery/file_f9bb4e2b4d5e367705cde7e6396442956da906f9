// ToolClasses.h
#pragma once

#include "FileLibrary.h"
#include "Directory_FileDetails.h"
/*
Transfer???filesystem?fs::path???????????????????????????????fs::path??????????SFC?????
MagicNumWriter??????
Directory_FileQueue????????????
Locator??????????
*/
class Transfer
{
public:
    std::wstring convertToWString(const std::string &s);
    fs::path transPath(const std::string &p);
};

class NumsWriter
{
<<<<<<< HEAD:CompressorFileSystem/DataCommunication/include/ToolClasses.h
public:
    template <typename T>
    void writeBinaryNums(T value, std::ofstream &ofstream)
    {
        if (!ofstream)
=======
private:
    std::ofstream &file;

public:
    template <typename T>
    void writeBinaryNums(T value, std::ofstream &file)
    {
        if (!file)
>>>>>>> b722976 (??????????¤????????K114514):DataStream/DataCommunication/include/ToolClasses.h
            throw std::runtime_error("writeBinaryNums() Error-noFile");
        // ?????

        static_assert(std::is_trivially_copyable_v<T>,
                      "Cannot write non-trivially-copyable type");
        static_assert(!std::is_pointer_v<T>,
                      "Cannot safely write raw pointers");
        static_assert(!std::is_polymorphic_v<T>,
                      "Cannot safely write polymorphic types");
<<<<<<< HEAD:CompressorFileSystem/DataCommunication/include/ToolClasses.h
        if (!ofstream.write(reinterpret_cast<char *>(&value), sizeof(T))) // ???????????????
=======
        if (!file.write(reinterpret_cast<char *>(&value), sizeof(T))) // ???????????????
>>>>>>> b722976 (??????????¤????????K114514):DataStream/DataCommunication/include/ToolClasses.h
        {
            throw std::runtime_error("writeBinaryNums()Error-Failed to write");
        }
    }
    template <typename T>
    void writeBinaryNums(T value, std::fstream &fstream)//????fstream???
    {
        if (!fstream)
            throw std::runtime_error("writeBinaryNums() Error-noFile");
        // ?????

        static_assert(std::is_trivially_copyable_v<T>,
                      "Cannot write non-trivially-copyable type");
        static_assert(!std::is_pointer_v<T>,
                      "Cannot safely write raw pointers");
        static_assert(!std::is_polymorphic_v<T>,
                      "Cannot safely write polymorphic types");
        if (!fstream.write(reinterpret_cast<char *>(&value), sizeof(T))) // ???????????????
        {
            throw std::runtime_error("writeBinaryNums()Error-Failed to write");
        }
    }

    void appendMagicStatic();
};

class NumsReader
{
private:
    std::ifstream &file;

public:
    NumsReader(std::ifstream &file) : file(file) {};
    template <typename T>
    T readBinaryNums()
    {
        if (!file)
            throw std::runtime_error("readBinaryNums() Error-noFile");
        T value;
        static_assert(std::is_trivially_copyable_v<T>,
                      "Cannot write non-trivially-copyable type");
        static_assert(!std::is_pointer_v<T>,
                      "Cannot safely write raw pointers");
        static_assert(!std::is_polymorphic_v<T>,
                      "Cannot safely write polymorphic types");

        if (file.eof())
        {
            return T();
        }
        if (!file.read(reinterpret_cast<char *>(&value), sizeof(T)))
        {
            throw std::runtime_error("readBinaryNums()Error-Failed to read" + file.eof() ? " - End of File reached" : "");
        }
        return value;
    }
};

class Directory_FileQueue
{
private:
    struct Node
    {
        std::pair<Directory_FileDetails, FileCount_uint> data;
        Node *next;
        Node(const std::pair<const Directory_FileDetails, FileCount_uint> &val)
            : data(val), next(nullptr) {}
    };

    Node *frontNode;
    Node *rearNode;
    size_t count;

public:
    Directory_FileQueue();
    ~Directory_FileQueue();
    void clear();
    void push(std::pair<Directory_FileDetails, FileCount_uint> val);
    void pop();
    std::pair<Directory_FileDetails, FileCount_uint> &front();
    std::pair<Directory_FileDetails, FileCount_uint> &back();
    bool empty();
    size_t size();
};

class Directory_FIleQueueInterface
{
public:
    Directory_FileQueue Directory_FileQueue;
};

class Locator
{
public:
    Locator() = default;
    void offsetLocator(std::ofstream &outFile, FileSize_uint offset);
    void offsetLocator(std::ifstream &inFile, FileSize_uint offset);
    void offsetLocator(std::fstream &file, FileSize_uint offset) = delete;
    FileSize_uint getFileSize(const fs::path &filePathToScan, std::ofstream &outFile);
};