# <center>加密与压缩</center>
## <center>目录</center>
1. **[用户视角的应用](#1-用户视角的应用)**
   - [1.1 功能讨论](#11-功能讨论)
   - [1.2 GUI布局](#12-gui布局)
2. **[程序概览](#2-程序概览)**
   - [2.1 算法 / 定义概览](#21-算法--定义概览)
3. **[程序结构初步设计](#3-程序结构初步设计)**
   - [3.1 类（class）](#31-类-class)
   - [3.2 工作流程 / 类、对象之间的交互](#32-工作流程--类对象之间的交互)
4. **[板块―底层细节与技术](#4-板块底层细节与技术)**
   - [4.1 技术分析](#41-技术分析)
   - [4.2 用到的库](#42-用到的库)
5. **[板块―算法具体实现](#5-板块算法具体实现)**
   - [5.1 Heffman编码](#51-heffman编码)
   - [5.2 AES 加密](#52-aes-加密)
   - [5.3 文件](#53-文件)
6. **[安全问题](#6-安全问题)**
   - [6.1 线程的数量](#61-线程的数量)
7. **[最终实现]()**

## 1 用户视角的应用

### 1.1 讨论

>应用需要什么功能？  

我们需要尽可能给用户提供自由的压缩选项。  

【问题A1】  
是否需要加密？用什么算法加密？这在GUI界面中分别通过一个勾选器和列表选择器让用户操作。

【问题A2】  
在压缩时，可能需要处理多个文件一起压缩的情况。将多个文件整合成一个压缩包？所有文件分别独立成一个压缩包？或是在应用内可选择分类生成多个压缩包？需要提供一个选项供用户选择。

【问题A3】  
对于编码结构，用户可以选择是否将其独立成一个文件存放。

【问题A4】  
使用RSA加密可以实现特定用户间的数据加密传输。这时需要提供一个RSA密钥生成器。

【问题A5】  
可以选择从右键菜单栏中直接启动压缩任务。

[返回目录](#目录)

### 1.2 GUI布局

## 2 程序概览

### 2.1 算法 / 定义概览

+ **AES加密**：高级加密标准，高级加密标准对称性加密算法。
+ **RSA加密**：非对称性加密算法。（备选）
+ **流加密**：逐字节加密处理。（备选）
+ **Heffman编码**：基于前缀码的无损压缩算法。
+ **BWT编码**：基于后缀数组的压缩数据预处理算法。（备选）
+ **Qt**：c++的GUI框架，跨平台兼容。
+ **文件头**：包含压缩文件基本信息的数据结构。
+ **位图(bitmap)**：按位存储状态。
+ **信号与槽**：Qt框架的核心思想，响应式GUI编程。
+ **锁**：控制临界区的变量，持有锁的线程可以进入临界区。
+ **条件变量**：核心为休眠队列，通过信号唤醒队列中的线程。
+ **信号量**：类似Minecraft的红石比较器，或AE的发信器。控制进入临界区线程的数量。
+ **死锁**：多个线程争抢锁的形式构成单向环图的状况。造成线程永久的休眠。
+ **系统调用**：由操作系统提供给应用程序的接口。通常是受限操作，由操作系统执行。

[返回目录](#目录)

## 3 程序结构初步设计

>实现：c++/c

### 3.1 类 （ class ）

1. **MainWindow (主线程)**

    主GUI类。用于创建压缩任务、提供功能选择、显示任务状态。

2. **Connector**

    数据缓冲类，它是一个类似“连接器”的存在，需要连接输入和输出的对象（允许两个以上），存放在队列里，主动顺序启动被连接的算法模块。  
    一个类内有多个在堆上的缓冲块，存放于列表，记录id，方便多线程的使用。
    每次处理需要按id顺序进行，比如、从id1到4，依次从文件获取数据，依次把数据给Heffman。  
    为了适应有多个连接口的情况，连接器有两个这样的缓冲块列表。 
    主动传输的方式是，将其数据块的引用传递给某个对象。  
    所有可能会被CharBuffer连接的对象，都要继承自一个“口”基类，Connector内存放该基类引用，与算法模块交互并启动算法。

3. **Producer**

    文件处理类、Heffman、Heffmancoder、Aes的基类。是抽象类，内部是纯虚函数receive()，和output()，  
    用作纯粹地接口。如果有其他特殊的操作，可以写在里面。  
    Connerctor可能也要继承该类。

4. **Fileioer**

    进行文件读写的类，读文件内容到缓冲块内。  
    使用文件头，保存文件指针、文件类型、文件格式、文件路径信息、文件名。
    使用压缩文件头，保存文件之间的结构。 
    对于多文件，将每个文件的自定义文件头作为数据，加入缓冲块。  
    具体来说。该类中存储了多个对应文件的文件指针。首先当然是先把压缩文件头放入缓冲区。
    然后对于每个文件，将其对应的文件头放入缓冲区，再放入文件内容，直到文件指针到尽头，开始下一个文件处理。  

    总结：该类对象保存一个文件头列表、一个压缩文件头，具有生成这些头的方法（压缩），以及根据数据流中出现的这些头创建文件的方法（解压）。

    另一种想法：将压缩文件头与文件头集中放在前面，并用一个特殊标记维护文件内容的始末。这样解压时可以掌握全局，方便调错与管理。  
    这种想法需要具有生成这些文件头的方法（压缩+解压），以及根据这些文件头创建文件的方法（解压）。

5. **AEScoder**

    负责AES加密的类。，

6. **Heffman**

    实现赫夫曼编码的类。拥有友元Heffmancoder   

7. **Heffmancoder**

    根据Heffman编码结果进行翻译。其中根据状态标识，决定是否独立存放编码文件。

8. **Runer**

    保存功能开关状态，协调任务进行的类。可以启动并管理线程。  

[返回目录](#目录)

### 3.2 工作流程 / 类、对象之间的交互

首先我们指定要处理的文件们，可以在GUI界面中【选择文件夹或文件】，或者直接拖放到GUI，这时候这些文件名被加载到 Fileioer 中。之后完成基本功能的选择，点击【开始】就可以启动一个处理任务，其状态显示在GUI的【任务栏】中，线程任务完成后，状态显示从任务栏移除。  
压缩结果暂且存到程序目录下的指定文件夹。

这之中需要注意如下问题：

#### 【问题B1】程序的行为  

程序行为可能是：只压缩、先加密后压缩。

这些行为由用户对于功能的选择，构成不同的状态组合而产生，应该通过什么样的结构去将特定组合映射到对象的交互行为？或者，要如何让对象共享这些状态？



#### 【问题B2】程序行为――数据处理模块的调度

接续问题B1，该如何调度负责加密和压缩的对象？使用Connector连接，并让Connector主动启动处理算法。这样可以根据用户功能选择，生成不同的Connector对象。
写好轮转运行的规则，将这些对象存储在列表中顺序调用即可。  

[返回目录](#目录)

## 4 板块―底层细节与技术

### 4.1 技术分析

#### 【问题C1】文件夹的处理

我们需要提供处理文件夹的能力。暂且给出两种方案：  
① 将文件结构信息保存在压缩文件头中。文件与文件夹用两种符号标识。压缩时递归地扫描文件，解压时递归地构建文件（当遇到文件夹标识，创建一个文件夹）。  
② 在类unix系统下，文件夹实际上是一个特殊文件类型。可以通过系统调用获取其 inode 内容，然后构建目录表。

>直接 inode 访问过于底层，难以做兼容或扩展。这里只提出作为参考。

#### 【问题C2】线程何时创建

该如何安排线程？  

>只有必要时才启用多线程。不合理的安排会导致极糟糕的性能和内存安全等问题。这是由于锁引入的开销，并且必须考虑临界区访问、死锁活锁等问题，增加了程序的复杂性。

首先可以肯定，我们需要为一个任务流程安排一个线程，以免耗时的压缩操作卡死GUI界面。**目前暂时决定用单线程、串行地完成任务流程的所有操作。对于流程中的压缩、加密步骤，使用多线程加速。**

#### 【问题C3】数据块的传递

数据缓冲。加密到压缩之间需要一次数据缓冲。压缩到文件输出间需要一次数据缓冲。 使用Connector对象解决，连接器类似一个泵，所有操作由它主动发起。 

>文件类 -> 连接器A -> Heffman -> 连接器B -> AES -> 连接器B -> 文件类。   

缓冲区的大小默认为4KB。  
在任务线程中，维护了连接器队列，连接器是顺序地、依次地工作的。  
而如果着眼于数据处理模块，对于连接器A连接的文件类与Heffman类――文件类与Heffman轮转工作，缓冲块空时文件类工作，缓冲块满时Heffman的统计部分工作；对于连接器B，由Heffman,。

#### 【问题C4】

动态库 / 共享库 的使用。由于有多个线程使用同样的处理逻辑，我们可以考虑将这部分逻辑封装进动态库中。

#### 【问题C5】

文件结构。在项目目录下，

#### 【问题C】

跨平台兼容。如果使用了**系统调用**，需要用宏进行包装。  
编写Makefile，以方便在不同环境下编译运行。


#### 【问题C】

迟到的优化。加密与压缩的性能。

>我们不需要过早地考虑优化，或许有前瞻性的设计很重要，但代码越简单越好。

如果最后发现加密和压缩的速度过慢，再考虑如何加速。

[返回目录](#目录)

### 4.2 用到的库

[返回目录](#目录)

## 5 板块―算法具体实现

### 5.1 Heffman编码

多线程设计：每个线程负责一个Connector的缓冲块（使用引用存在Heffman内），并且拥有独立的哈希表。  
线程的哈希表生成完毕后，归并到总哈希表。之后使用优先队列存储表的索引，  
用于贪心生成编码树。进行到这一步，需要再读一次文件，这里
重新唤醒之前的线程，并行翻译，由Connector对象将数据块顺序传给Aes。


### 5.2 AES 加密




### 5.3 文件



[返回目录](#目录)

## 6 安全问题

### 6.1 线程的数量

如果用户添加了过多的任务，那么就会启动对应数量的线程。这会使得每个线程的处理变慢，同时对操作系统来说也可能是一个灾难。  
必须要限制线程的数量。决定任务主线程数量上限为当前OS拥有的逻辑CPU数量。过多的任务请在队列中等待创建。

[返回目录](#目录) 