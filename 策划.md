<<<<<<< HEAD
# <center>加密与压缩</center>
## <center>目录</center>
1. **用户视角的应用**
  - 1.1 功能讨论
  - 1.2 GUI布局
2. **程序概览**
  - 2.1 算法 / 定义概览
  -
3. **程序结构初步设计**
  -
  -
4. **板块—底层细节与技术**
  -
  -
5. **板块—算法具体实现**
  -
  -
6. **安全问题**
7. **最终实现**

## 1 用户视角的应用

### 1.1 讨论

>应用需要什么功能？  

我们需要尽可能给用户提供自由的压缩选项。  

【问题A1】  
是否需要加密？用什么算法加密？这在GUI界面中分别通过一个勾选器和列表选择器让用户操作。

【问题A2】  
在压缩时，可能需要处理多个文件一起压缩的情况。将多个文件整合成一个压缩包？所有文件分别独立成一个压缩包？或是在应用内可选择分类生成多个压缩包？需要提供一个选项供用户选择。

【问题A3】  
对于编码结构，用户可以选择是否将其独立成一个文件存放。

【问题A4】  
使用RSA加密可以实现特定用户间的数据加密传输。这时需要提供一个RSA密钥生成器。

【问题A5】  
可以选择从右键菜单栏中直接启动压缩任务。

### 1.2 GUI布局

## 2 程序概览

### 2.1 算法 / 定义概览

+ **AES加密**：高级加密标准，高级加密标准对称性加密算法。
+ **RSA加密**：非对称性加密算法。（备选）
+ **流加密**：逐字节加密处理。（备选）
+ **Heffman编码**：基于前缀码的无损压缩算法。
+ **BWT编码**：基于后缀数组的压缩数据预处理算法。（备选）
+ **Qt**：c++的GUI框架，跨平台兼容。
+ **文件头**：包含压缩文件基本信息的数据结构。
+ **位图(bitmap)**：按位存储状态。
+ **信号与槽**：Qt框架的核心思想，响应式GUI编程。
+ **锁**：控制临界区的变量，持有锁的线程可以进入临界区。
+ **条件变量**：核心为休眠队列，通过信号唤醒队列中的线程。
+ **信号量**：类似Minecraft的红石比较器，或AE的发信器。控制进入临界区线程的数量。
+ **死锁**：多个线程争抢锁的形式构成单向环图的状况。造成线程永久的休眠。
+ **系统调用**：由操作系统提供给应用程序的接口。通常是受限操作，由操作系统执行。


## 3 程序结构初步设计

>实现：c++/c

### 3.1 类 （ class ）

1. **MainWindow (主线程)**

    主GUI类。用于创建压缩任务、提供功能选择、显示任务状态。

2. **Connector**

    数据缓冲类，它是一个类似“连接器”的存在，需要连接输入和输出的对象，主动传输。  
    一个类内有多个在堆上的缓冲块，存放于一个列表，记录id，方便多线程的使用。
    每次处理需要按id顺序进行，比如、从id1到4，依次从文件获取数据，依次把数据给Heffman。  
    主动传输的方式是，将其数据块传递给某个对象。  
    所有可能会被CharBuffer连接的对象，都要继承自一个“口”类。

3. **Producer**

    文件处理类、Heffman、Heffmancoder、Aes的基类。是抽象类，内部是纯虚函数receive()，和output()，  
    用作纯粹地接口。如果有其他特殊的操作，可以写在里面。  
    Connerctor可能也要继承该类。

4. **Fileioer**

    进行文件读写的类。包含文件头结构，文件路径信息，文件名，

5. **AEScoder**

    负责AES加密的类。，

6. **Heffman**

    实现赫夫曼编码的类。拥有友元Heffmancoder   

7. **Heffmancoder**

    根据Heffman编码结果进行翻译。

8. **Runer**

    保存功能开关状态，协调任务进行的类。可以启动并管理线程。  



### 3.2 工作流程 / 类、对象之间的交互

首先我们指定要处理的文件们，可以在GUI界面中【选择文件夹或文件】，或者直接拖放到GUI，这时候这些文件名被加载到 Fileioer 中。之后完成基本功能的选择，点击【开始】就可以启动一个处理任务，其状态显示在GUI的【任务栏】中，线程任务完成后，状态显示从任务栏移除。  
压缩结果暂且存到程序目录下的指定文件夹。

这之中需要注意如下问题：

#### 【问题B1】  

程序行为可能是：只压缩、先加密后压缩。产生的结果可能是：单个压缩文件、单个压缩文件与其编码结构、多个压缩文件、多个压缩文件与其编码结构。

这些行为由用户对于功能的选择，构成不同的状态组合而产生，应该通过什么样的结构去将特定组合映射到对象的交互行为？或者，要如何让对象共享这些状态？



#### 【问题B2】

接续问题B1，该如何调度负责加密和压缩的对象？使用Connector连接，使用 ？类调度Connector。
=======
# <center>ѹ</center>
## <center>Ŀ¼</center>
1. **[ûӽǵӦ](#1-ûӽǵӦ)**
   - [1.1 ](#11-)
   - [1.2 GUI](#12-gui)
2. **[](#2-)**
   - [2.1 㷨 / ](#21-㷨--)
3. **[ṹ](#3-ṹ)**
   - [3.1 ࣨclass](#31--class)
   - [3.2  / ࡢ֮Ľ](#32---֮Ľ)
4. **[顪ײϸ뼼](#4-ײϸ뼼)**
   - [4.1 ](#41-)
   - [4.2 õĿ](#42-õĿ)
5. **[顪㷨ʵ](#5-㷨ʵ)**
   - [5.1 Heffman](#51-heffman)
   - [5.2 AES ](#52-aes-)
   - [5.3 ļ](#53-ļ)
6. **[ȫ](#6-ȫ)**
   - [6.1 ̵߳](#61-̵߳)
7. **[ʵ]()**

## 1 ûӽǵӦ

### 1.1 

>ӦҪʲôܣ  

Ҫܸûṩɵѹѡ  

A1  
ǷҪܣʲô㷨ܣGUIзֱͨһѡбѡû

A2  
ѹʱҪļһѹļϳһѹļֱһѹӦڿѡɶѹҪṩһѡûѡ

A3  
ڱṹûѡǷһļš

A4  
ʹRSAܿʵضûݼܴ䡣ʱҪṩһRSAԿ

A5  
ѡҼ˵ֱѹ

[Ŀ¼](#Ŀ¼)

### 1.2 GUI

## 2 

### 2.1 㷨 / 

+ **AES**߼ܱ׼߼ܱ׼ԳԼ㷨
+ **RSA**ǶԳԼ㷨ѡ
+ ****ֽڼܴѡ
+ **Heffman**ǰ׺ѹ㷨
+ **BWT**ں׺ѹԤ㷨ѡ
+ **Qt**c++GUIܣƽ̨ݡ
+ **ļͷ**ѹļϢݽṹ
+ **λͼ(bitmap)**λ洢״̬
+ **ź**Qtܵĺ˼룬ӦʽGUI̡
+ ****ٽı߳̿Խٽ
+ ****Ϊ߶УͨźŻѶе̡߳
+ **ź**MinecraftĺʯȽAEķƽٽ̵߳
+ ****߳ʽɵͼ״߳õߡ
+ **ϵͳ**ɲϵͳṩӦóĽӿڡͨ޲ɲϵͳִС

[Ŀ¼](#Ŀ¼)

## 3 ṹ

>ʵ֣c++/c

### 3.1   class 

1. **MainWindow (߳)**

    GUIࡣڴѹṩѡʾ״̬

2. **Connector**

    ݻ࣬һơĴڣҪĶϣڶ˳ӵ㷨ģ顣  
    һжڶϵĻ飬б¼id̵߳ʹá
    ÿδҪid˳У硢id14δļȡݣΰݸHeffman  
    ΪӦжӿڵĻб 
    ķʽǣݿôݸĳ  
    пܻᱻCharBufferӵĶ󣬶Ҫ̳һڡ࣬ConnectorڴŸûã㷨ģ齻㷨

3. **Producer**

    ļࡢHeffmanHeffmancoderAesĻࡣǳ࣬ڲǴ麯receive()output()  
    ؽӿڡĲд档  
    ConnerctorҲҪ̳иࡣ

4. **Fileioer**

    ļд࣬ļݵڡ  
    ʹļͷļָ롢ļ͡ļʽļ·Ϣļ
    ʹѹļͷļ֮Ľṹ 
    ڶļÿļԶļͷΪݣ뻺顣  
    ˵д洢˶Ӧļļָ롣ȵȻȰѹļͷ뻺
    ȻÿļӦļͷ뻺ٷļݣֱļָ뵽ͷʼһļ  

    ܽ᣺󱣴һļͷбһѹļͷЩͷķѹԼгֵЩͷļķѹ

    һ뷨ѹļͷļͷзǰ棬һάļݵʼĩѹʱȫ֣  
    뷨ҪЩļͷķѹ+ѹԼЩļͷļķѹ

5. **AEScoder**

    AESܵࡣ

6. **Heffman**

    ʵֺշࡣӵԪHeffmancoder   

7. **Heffmancoder**

    Heffmanз롣и״̬ʶǷűļ

8. **Runer**

    湦ܿ״̬Эеࡣ̡߳  

[Ŀ¼](#Ŀ¼)

### 3.2  / ࡢ֮Ľ

ָҪļǣGUIСѡļлļֱϷŵGUIʱЩļص Fileioer С֮ɻܵѡ񣬵ʼͿһ״̬ʾGUIġУ߳ɺ״̬ʾƳ  
ѹҴ浽Ŀ¼µָļС

֮Ҫע⣺

#### B1Ϊ  

Ϊǣֻѹȼܺѹ

ЩΪûڹܵѡ񣬹ɲͬ״̬϶ӦͨʲôĽṹȥضӳ䵽ĽΪߣҪöЩ״̬



#### B2Ϊݴģĵ

B1εȸܺѹĶʹConnectorӣConnector㷨ԸûѡɲͬConnector
дתеĹ򣬽Щ洢б˳üɡ  

[Ŀ¼](#Ŀ¼)

## 4 顪ײϸ뼼

### 4.1 

#### C1ļеĴ

ҪṩļеҸַ  
 ļṹϢѹļͷСļļַűʶѹʱݹɨļѹʱݹعļļбʶһļУ  
 unixϵͳ£ļʵһļͨ͡ϵͳûȡ inode ݣȻ󹹽Ŀ¼

>ֱ inode ʹڵײ㣬ݻչֻΪο

#### C2̺߳ʱ

ΰ̣߳  

>ֻбҪʱö̡߳İŻᵼ¼ܺڴ氲ȫ⡣Ŀұ뿼ٽʡ⣬˳ĸԡ

ȿԿ϶ҪΪһ̰һ̣߳ʱѹGUI档**Ŀǰʱõ̡߳е̵веѹܲ裬ʹö̼߳١**

#### C3ݿĴ

ݻ塣ܵѹ֮Ҫһݻ塣ѹļҪһݻ塣 ʹConnectorһãв 

>ļ -> A -> Heffman -> B -> AES -> B -> ļࡣ   

ĴСĬΪ4KB  
߳УάУ˳ءεعġ  
ݴģ飬AӵļHeffmanࡪļHeffmanתʱļ๤ʱHeffmanͳƲֹBHeffman,

#### C4

̬ /  ʹáж߳ʹͬĴ߼ǿԿǽⲿ߼װ̬С

#### C5

ļṹĿĿ¼£

#### C

ƽ̨ݡʹ**ϵͳ**Ҫúаװ  
дMakefileԷڲͬ±С


#### C

ٵŻѹܡ

>ǲҪؿŻǰհԵƺҪԽԽá

ּܺѹٶȹٿμ١

[Ŀ¼](#Ŀ¼)

### 4.2 õĿ

[Ŀ¼](#Ŀ¼)

## 5 顪㷨ʵ

### 5.1 Heffman

߳ƣÿ̸߳һConnectorĻ飨ʹôHeffmanڣӵжĹϣ  
̵߳ĹϣϺ󣬹鲢ܹϣ֮ʹȶд洢  
̰ɱеһҪٶһļ
»֮ǰ̣߳з룬Connectorݿ˳򴫸Aes


### 5.2 AES 
>>>>>>> koharu




<<<<<<< HEAD

## 4 板块—底层细节与技术

### 4.1 技术分析

#### 【问题C1】

我们需要提供处理文件夹的能力。暂且给出两种方案：  
① 将文件结构信息保存在压缩文件头中。文件与文件夹用两种符号标识。压缩时递归地扫描文件，解压时递归地构建文件（当遇到文件夹标识，创建一个文件夹）。  
② 在类unix系统下，文件夹实际上是一个特殊文件类型。可以通过系统调用获取其 inode 内容，然后构建目录表。

>直接 inode 访问过于底层，难以做兼容或扩展。这里只提出作为参考。

#### 【问题C2】

该如何安排线程？  

>只有必要时才启用多线程。不合理的安排会导致极糟糕的性能和内存安全等问题。这是由于锁引入的开销，并且必须考虑临界区访问、死锁活锁等问题，增加了程序的复杂性。

首先可以肯定，我们需要为一个任务安排一个线程，以免耗时的压缩操作卡死GUI界面。目前暂时决定用一个线程完成任务的所有操作。

#### 【问题C3】

数据缓冲。加密到压缩之间需要一次数据缓冲。压缩到文件输出间需要一次数据缓冲。  
>压缩 比特缓冲输出 → 缓冲区A → 加密 → 缓冲区B → 文件    

将缓冲区的大小暂定为4KB。采用轮转的做法，缓冲区A满时加密处理对象工作，缓冲区A空时压缩对象工作。缓冲区B同理。

#### 【问题C4】

动态库 / 共享库 的使用。由于有多个线程使用同样的处理逻辑，我们可以考虑将这部分逻辑封装进动态库中。

#### 【问题C5】

文件结构。在项目目录下，

#### 【问题C】

跨平台兼容。如果使用了**系统调用**，需要用宏进行包装。  
编写Makefile，以方便在不同环境下编译运行。


#### 【问题C】

迟到的优化。加密与压缩的性能。

>我们不需要过早地考虑优化，或许有前瞻性的设计很重要，但代码越简单越好。

如果最后发现加密和压缩的速度过慢，再考虑如何加速。

### 4.2 用到的库



## 5 板块—算法具体实现

### 5.1 Heffman编码

多线程设计：每个线程负责一个Connector的缓冲块，并且拥有独立的哈希表。  
线程的哈希表生成完毕后，归并到总哈希表。之后使用优先队列存储表的索引，  
用于贪心生成编码树。进行到这一步，需要再读一次文件，这里
重新唤醒之前的线程，并行翻译，由Connector对象将数据块顺序传给Aes。


### 5.2 AES 加密





## 6 安全问题

### 6.1 线程的数量

如果用户添加了过多的任务，那么就会启动对应数量的线程。这会使得每个线程的处理变慢，同时对操作系统来说也可能是一个灾难。  
必须要限制线程的数量。决定任务主线程数量上限为当前OS拥有的逻辑CPU数量。过多的任务请在队列中等待创建。

=======
### 5.3 ļ



[Ŀ¼](#Ŀ¼)

## 6 ȫ

### 6.1 ̵߳

û˹ôͻӦ̡߳ʹÿ̵߳ĴͬʱԲϵͳ˵Ҳһѡ  
Ҫ̵߳߳ΪǰOSӵе߼CPUڶеȴ

[Ŀ¼](#Ŀ¼)
>>>>>>> koharu
