                       主要实现模块

【文件系统模块 - 压缩过程】

Directory_FileProcessor (目录文件处理器)
文件位置: CompressorFileSystem/DataCommunication/include/Directory_FileProcessor.h
         CompressorFileSystem/DataCommunication/src/Directory_FileProcessor.cpp

核心职责: 递归扫描源目录树，使用BFS(广度优先搜索)遍历，生成目录结构的二进制编码

directory_fileProcessor() - 主入口函数 (src/Directory_FileProcessor.cpp:4)
  输入: filePathToScan (用户选择的路径列表)
        fullOutPath (输出压缩文件路径)
        logicalRoot (逻辑根名称)
  功能流程:
    1. 初始化偏移量: offset = HEADER_SIZE (11字节), tempOffset = 0
    2. 调用 BinaryIO_Writter::writeBlankSeparatedStandard() 预留分割标准位置
    3. 调用 BinaryIO_Writter::writeLogicalRoot() 写入逻辑根节点
       - 记录根节点标志 (LOGICAL_ROOT_FLAG)
       - 记录根节点名称大小和内容
       - 记录根节点下的子元素总数
    4. 调用 BinaryIO_Writter::writeRoot() 处理filePathToScan中的各路径
       - 对于每个路径: 若是文件则记录; 若是目录则入队
    5. 进入BFS循环, 调用 scanFlow() 持续处理目录队列

scanFlow() - BFS遍历函数 (src/Directory_FileProcessor.cpp:43)
  功能: 维护队列式循环, 逐个处理directoryQueue中的目录
  循环过程:
    当 directoryQueue 非空:
      取出队首目录
      调用 BinaryIO_Writter::binaryIO_Writer() 扫描该目录内容
      返回后队首目录出队
  结果: 所有子目录被递归入队并处理, 直到队列为空


BinaryIO_Writer (二进制IO写入器)
文件位置: CompressorFileSystem/DataCommunication/include/BinaryIO_Writer.h
         CompressorFileSystem/DataCommunication/src/BinaryIO_Writer.cpp

核心职责: 目录/文件的单层扫描与二进制编码, 字节级写入与偏移回填

binaryIO_Writer() - 单层扫描函数 (src/BinaryIO_Writer.cpp:2)
  输入: FilePath对象 (包含要扫描的路径)
       Directory_FIleQueueInterface (目录队列)
       tempOffset (当前块累计偏移)
       offset (全局偏移)
  扫描过程:
    通过 fs::directory_iterator 遍历指定路径的单层条目
    对每个条目调用 writeStorageStandard() 进行分类处理
  特性: 每层扫描只涉及一级目录和文件, 不进行递归

writeStorageStandard() - 标准分发函数 (src/BinaryIO_Writer.cpp:51)
  职责: 根据条目类型(文件/目录/符号链接)分发到对应的写入函数
  缓冲管理:
    - 累计 tempOffset 记录当前块的大小
    - 当 tempOffset >= BUFFER_SIZE (65536字节):
      * 调用 writeSeparatedStandard() 回填当前块大小
      * offset += tempOffset
      * tempOffset 重置为0
      * 调用 writeBlankSeparatedStandard() 预留下一块的标准头部

writeFileStandard() - 文件标准写入 (src/BinaryIO_Writer.cpp:95)
  写入内容 (按序):
    1. FILE_FLAG (1字节) - 标记这是一个文件
    2. fileNameSize (sizeof(FileNameSize_uint)) - 文件名长度
    3. fileName (fileNameSize字节) - 文件名
    4. originSize (sizeof(FileSize_uint)) - 原始文件大小 (未压缩)
    5. compressedSize占位 (sizeof(FileSize_uint)) - 预留为0, 后续压缩完回填
  更新: tempOffset += FLAG_SIZE + sizeof(FileNameSize_uint) + fileNameSize + 2*sizeof(FileSize_uint)

writeDirectoryStandard() - 目录标准写入 (src/BinaryIO_Writer.cpp:83)
  写入内容 (按序):
    1. DIRECTORY_FLAG (1字节) - 标记这是一个目录
    2. directoryNameSize (sizeof(FileNameSize_uint)) - 目录名长度
    3. directoryName (directoryNameSize字节) - 目录名
    4. childCount (sizeof(FileCount_uint)) - 该目录下的直接子元素数量
  目录队列: 同时将此目录及其子元素数量入队 {directoryDetails, childCount}
  更新: tempOffset += FLAG_SIZE + sizeof(FileNameSize_uint) + directoryNameSize + sizeof(FileCount_uint)

writeSymbolLinkStandard() - 符号链接写入 (src/BinaryIO_Writer.cpp:128)
  写入内容 (按序):
    1. SYMBOL_LINK_FLAG (1字符) - 标记这是符号链接
    2. linkNameSize (sizeof(FileNameSize_uint)) - 链接名称长度
    3. targetPathSize (sizeof(FileNameSize_uint)) - 目标路径长度
    4. linkName (linkNameSize字节) - 链接名称
    5. targetPath (targetPathSize字节) - 目标路径
  特性: 符号链接不递归展开, 仅记录链接关系

writeLogicalRoot() - 逻辑根写入 (src/BinaryIO_Writer.cpp:143)
  写入内容 (按序):
    1. LOGICAL_ROOT_FLAG (1字节) - 标记逻辑根
    2. rootNameSize (sizeof(FileNameSize_uint)) - 根名称长度
    3. rootName (rootNameSize字节) - 根名称
    4. childCount (sizeof(FileCount_uint)) - 根节点下的直接子元素数量
  特性: 逻辑根是虚拟节点, 用于处理多路径压缩情况

writeSeparatedStandard() - 块标准回填 (src/BinaryIO_Writer.cpp:108)
  功能: 回填前面预留的分割标准中的块大小字段
  操作:
    1. 计算回填位置: offset + FLAG_SIZE
    2. 使用 locator.offsetLocator() 移动写指针到回填位置
    3. 写入 tempOffset (当前块的实际大小)
    4. 移动写指针到文件末尾继续写入

writeBlankSeparatedStandard() - 空分割标准预留 (src/BinaryIO_Writer.cpp:115)
  写入内容:
    1. SEPARATED_FLAG (1字节) - 分割标志
    2. blockSize占位 (sizeof(DirectoryOffsetSize_uint)) - 预留为0
    3. ivNum占位 (sizeof(IvSize_uint)) - 预留为0, 用于解密时的IV
  目的: 为下一块预留结构头部, 供后续回填使用

writeBlankSeparatedStandardForEncryption() - 加密模式分割标准 (src/BinaryIO_Writer.cpp:122)
  写入内容:
    1. SEPARATED_FLAG (1字节) - 分割标志
    2. blockSize占位 (sizeof(DirectoryOffsetSize_uint)) - 预留为0
  区别: 加密模式不预留IV字段(IV在数据区加密后内嵌)

【数据块结构】
目录块的逻辑组织:

[HEADER_SIZE字节]
  |
  v
[SEPARATED_FLAG] [blockSize=0] [ivNum=0]         <- 第1块分割标准(预留)
[LOGICAL_ROOT_FLAG] [rootNameSize] [rootName]    <- 逻辑根
[childCount]
[FILE_FLAG] [fileNameSize] [fileName]            <- 逻辑根下的直接元素
[originSize] [compressedSize=0]
  ... (重复FILE/DIRECTORY_FLAG条目) ...
[FILE_FLAG] [nameSize] [name] ... [0]
[DIRECTORY_FLAG] [nameSize] [name] [childCount=0]
[SEPARATED_FLAG] [blockSize=实际大小] [ivNum=0]  <- 第1块分割标准(回填)
  |
  v
[SEPARATED_FLAG] [blockSize=0] [ivNum=0]         <- 第2块分割标准(预留)
[DIRECTORY_FLAG] [nameSize] [name] [childCount]  <- 处理下一层目录
  ... (重复标准条目) ...
[SEPARATED_FLAG] [blockSize=实际大小] [ivNum=0]  <- 第2块分割标准(回填)
  |
  v
... (重复多个块) ...
  |
  v
[MAGIC_NUM(4字节)]                               <- 文件末尾魔数


HeaderWriter (文件头与目录写入器)
文件位置: CompressorFileSystem/DataCommunication/include/HeaderWriter.h
         CompressorFileSystem/DataCommunication/src/HeaderWriter.cpp

架构: 采用策略模式, HeaderWriter是外观类, HeaderWriter_v0是具体实现

HeaderWriter::headerWriter() - 主协调函数 (src/HeaderWriter.cpp:42)
  输入: filePathToScan (源路径列表)
       outPutFilePath (输出.sy文件路径)
       logicalRoot (根节点名称)
  操作流程:
    1. 检查输出文件是否已存在, 若存在则抛异常
    2. 以二进制输出模式打开输出文件
    3. 调用 appendMagicStatic() 写入起始魔数 (4字节, 0xDEADBEEF)
    4. 调用 writeHeader() 写入文件头信息
    5. 调用 appendMagicStatic() 写入中间魔数
    6. 调用 writeDirectory() 递归扫描并写入目录结构
    7. 调用 appendMagicStatic() 写入末尾魔数
  异常处理: 任何阶段失败都抛出运行时异常, 调用方负责清理部分写入的文件

HeaderWriter_v0::writeHeader() - 文件头写入 (src/HeaderWriter.cpp:3)
  写入位置: 紧接第一个魔数之后
  写入内容 (按序):
    1. STRATEGY (sizeof(CompressStrategy_uint)) - 压缩策略(1=Huffman)
    2. VERSION (sizeof(CompressorVersion_uint)) - 版本号
    3. headerOffset占位 (sizeof(HeaderOffsetSize_uint)) - 预留为0
    4. directoryOffset占位 (sizeof(DirectoryOffsetSize_uint)) - 预留为0
  总长度: 11字节 (4+1+2+4, 包括第一个魔数)
  回填: headerOffset被回填为11 (表示整个文件头大小)

HeaderWriter_v0::writeDirectory() - 目录委托 (src/HeaderWriter.cpp:27)
  职责: 作为连接层, 将目录写入任务委托给 Directory_FileProcessor
  步骤:
    1. 创建 Directory_FileProcessor 对象
    2. 调用其 directory_fileProcessor() 方法执行BFS扫描和二进制编码
    3. 扫描完成后, 回填 directoryOffset 字段
    4. directoryOffset = 当前文件大小 + 4 (末尾魔数长度)

【目录块流向】
用户指定路径列表
    |
    v
HeaderWriter::headerWriter()
    |
    +---> writeHeader() - 写入文件头(11字节, 其中directoryOffset预留)
    |
    +---> writeDirectory()
             |
             v
         Directory_FileProcessor::directory_fileProcessor()
             |
             +---> writeLogicalRoot() - 写逻辑根
             |
             +---> writeRoot() - 遍历filePathToScan逐个处理
             |       (文件直接写, 目录入队)
             |
             +---> scanFlow() - BFS主循环
                     |
                     +---> binaryIO_Writer() - 单层扫描
                             |
                             +---> writeStorageStandard() - 分类分发
                                     |
                                     +---> writeFileStandard()
                                     +---> writeDirectoryStandard()
                                     +---> writeSymbolLinkStandard()
                                     +---> writeSeparatedStandard(回填)
                                     +---> writeBlankSeparatedStandard()

    |
    +---> 回填 directoryOffset 字段


【文件系统模块 - 解压过程】

BinaryIO_Loader (二进制IO加载器)
文件位置: CompressorFileSystem/DataCommunication/include/BinaryIO_Loader.h
         CompressorFileSystem/DataCommunication/src/BinaryIO_Loader.cpp

核心职责: 从.sy文件读取目录块, 解密并解析目录结构, 提供文件队列供解压流程使用

headerLoaderIterator() - 主读取函数 (src/BinaryIO_Loader.cpp:3)
  输入: Aes对象 (用于解密目录块)
  执行流程:
    1. 首次调用时(tellg()==0):
       - 读取固定的HEADER_SIZE字节到buffer
       - 从buffer提取Header结构体(魔数、版本号、headerOffset、directoryOffset)
       - 验证两个魔数值是否为MAGIC_NUM
       - 校验directoryOffset非零
       - 设置offset = directoryOffset - HEADER_SIZE (剩余待读字节数)
    2. 若offset == sizeof(SizeOfMagicNum_uint)(4字节):
       - 读取末尾魔数进行验证
       - 调用 allLoopDone() 标记完成
       - 返回
    3. 当offset > 0:
       - 循环调用 loadBySepratedFlag() 逐块读取和解析目录数据
       - 每次调用减少offset

loadBySepratedFlag() - 块读取与解析 (src/BinaryIO_Loader.cpp:62)
  每个数据块的处理:
    1. 读取分割标志字节(SEPARATED_FLAG)
    2. 读取该块的大小 tempOffset
    3. 读取IV值 ivNum (用于AES解密)
    4. 更新剩余偏移: offset -= SEPARATED_STANDARD_SIZE + tempOffset
    5. 计算实际读取大小:
       - 若 tempOffset == 0: readSize = offset - 4 (预留末尾魔数)
       - 否则: readSize = tempOffset
    6. 记录当前块的文件位置和大小到pos向量 (供后续加密时回填使用)
    7. 从输入文件读取 readSize 字节到buffer
    8. 若 ivNum != 0(表示数据被加密):
       - 将ivNum和buffer拼接成 blockWithIv
       - 调用 aes.doAes(2, blockWithIv, decryptedBlock) 解密
       - 使用decryptedBlock替换buffer
    9. 调用 Directory_FileParser::parser() 解析buffer中的目录条目
       - parser()负责逐条目解析并入队(fileQueue/directoryQueue)
    10. 若 tempOffset == 0: offset -= readSize (到达末尾)

【重要队列】
fileQueue - 文件队列
  存储: {Directory_FileDetails, compressedSize}对
  用途: 解压时逐个取出文件对象, 从.sy文件提取压缩数据进行解压

directoryQueue - 目录队列
  存储: {Directory_FileDetails, childCount}对
  用途: BFS遍历时使用, 记录待处理目录及其子元素数

directoryQueue_ready - 目录就绪队列
  存储: fs::path (完整的绝对目录路径)
  用途: 解压时先创建所有目录结构, 再创建文件


Directory_FileParser (目录文件解析器)
文件位置: CompressorFileSystem/DataCommunication/include/Directory_FileParser.h
         CompressorFileSystem/DataCommunication/src/Directory_FileParser.cpp

核心职责: 从二进制buffer中解析目录结构, 构造Directory_FileDetails对象并入队

parser() - 主解析分发 (src/Directory_FileParser.cpp:138)
  输入: bufferPtr (当前解析位置, 引用传递, 自动更新)
       countOfKidDirectory (当前处理中目录的子元素数, 引用传递)
  处理:
    1. 读取标志字节(FILE_FLAG/DIRECTORY_FLAG/LOGICAL_ROOT_FLAG)
    2. 根据标志调用对应的解析函数:
       FILE_FLAG -> fileParser()
       DIRECTORY_FLAG -> directoryParser()
       LOGICAL_ROOT_FLAG -> rootParser()
    3. 递减 countOfKidDirectory

fileParser() - 文件解析 (src/Directory_FileParser.cpp:28)
  提取内容:
    1. 调用 fileName_fileSizeParser() 读取文件名长度和内容
    2. 调用 numsParser<FileSize_uint>() 读取原始文件大小
    3. 区分压缩/解压模式:
       压缩模式(parserMode==1):
         - compressedSize_or_Offset = 根据当前全局偏移计算回填位置
         - 跳过预留的compressedSize字段(不实际读值)
       解压模式(parserMode==2):
         - compressedSize_or_Offset = 读取实际的压缩大小
    4. 调用 pathConnector() 拼接完整路径
    5. 构造 Directory_FileDetails 对象
    6. 将 {fileDetails, compressedSize_or_Offset} 入队fileQueue

directoryParser() - 目录解析 (src/Directory_FileParser.cpp:60)
  提取内容:
    1. 读取目录名长度和内容
    2. 读取子元素数量 count
    3. 拼接完整路径
    4. 构造 Directory_FileDetails 对象
    5. 将 {directoryDetails, count} 入队directoryQueue

rootParser() - 逻辑根解析 (src/Directory_FileParser.cpp:77)
  在压缩模式(parserMode==1):
    逐个处理filePathToScan中的路径:
      - 根据标志判断是文件还是目录
      - 读取元数据
      - 构造对象并直接使用fullPath(用户指定路径)
    若directoryQueue为空则设置noDirec标志
  在解压模式(parserMode==2):
    - 拼接 root / rootName 作为虚拟根路径
    - 将其入队directoryQueue
    - 后续处理时会在此根下恢复目录树

【解析工具函数】
fileName_fileSizeParser() (src/Directory_FileParser.cpp:22)
  从buffer读取: [大小字段] [字符串内容]
  安全措施: 使用checkBounds()验证边界, 使用assign()避免未初始化问题

numsParser<T>() (src/Directory_FileParser.cpp:50)
  通用数值解析: 从buffer按字节读取T类型的数据
  支持类型: FileSize_uint, FileCount_uint, DirectoryOffsetSize_uint等

checkBounds() (src/Directory_FileParser.cpp:3)
  边界检查: 防止越界读取, 若超过buffer大小则抛异常


DataLoader (数据加载器)
文件位置: CompressorFileSystem/DataCommunication/include/DataLoader.h
         CompressorFileSystem/DataCommunication/src/DataLoader.cpp

核心职责: 从源文件按块读取原始数据, 供Huffman压缩或直接处理

dataLoader() - 压缩模式读取 (src/DataLoader.cpp:29)
  功能: 按BUFFER_SIZE字节块读取文件
  流程:
    1. 设置buffer大小为BUFFER_SIZE
    2. 从inFile读取最多BUFFER_SIZE字节
    3. 根据实际读取字节数(gcount)调整buffer大小
    4. 若gcount==0说明到达文件末尾, 调用done()标记完成

reset() - 文件切换 (src/DataLoader.cpp:13)
  功能: 关闭当前文件, 打开新文件
  先决条件: 必须在上个文件读取完成(loadIsDone==true)后调用
  异常: 若尝试在文件打开状态下reset则抛异常

getBlock() - 块获取 (src/DataLoader.h:19)
  返回: 当前buffer的常引用
  用途: Huffman压缩时获取数据块

isDone() - 完成检查 (src/DataLoader.h:20)
  返回: loadIsDone标志状态


DataExporter (数据导出器)
文件位置: CompressorFileSystem/DataCommunication/include/DataExporter.h
         CompressorFileSystem/DataCommunication/src/DataExporter.cpp

核心职责: 将压缩/解压后的数据和元数据写入输出文件

exportDataToFile_Compression() - 压缩数据导出 (src/DataExporter.cpp:24)
  用于: 压缩循环中每次数据块导出
  流程:
    1. 移动写指针到文件末尾
    2. 调用 writeBlankSeparatedStandardForEncryption() 写分割标准头(预留大小)
    3. 从outFile.write() 写入加密后的压缩数据块
    4. 累计到processedFileSize
    5. 调用 thisBlockIsDone() 回填块大小

exportDataToFile_Decompression() - 解压数据导出 (src/DataExporter.cpp:39)
  用于: 解压循环中每次数据块导出
  流程:
    1. 移动写指针到文件末尾
    2. 从outFile.write() 写入解压后的数据
    3. flush() 强制写入磁盘
    4. 累计到processedFileSize

thisFileIsDone() - 文件完成回填 (src/DataExporter.cpp:14)
  触发: 单个源文件压缩完毕
  功能: 回填目录块中该文件对应的compressedSize字段
  操作:
    1. 移动写指针到offsetToFill位置(该字段在directoryOffset处的预留位置)
    2. 写入processedFileSize(该文件压缩后的总大小)
    3. processedFileSize重置为0

thisBlockIsDone() - 块完成回填 (src/DataExporter.cpp:3)
  触发: 单个数据块写入完毕
  功能: 回填分割标准中的blockSize字段
  操作:
    1. 记录当前写位置
    2. 回溯到分割标准的size字段位置
    3. 写入dataSize(该块的实际大小)
    4. 移动写指针回文件末尾


                    Huffman压缩算法实现

Heffman类 (HEFF = Huffman编码频率处理)
文件位置: CompressionModules/heffman/include/Heffman.h
         CompressionModules/heffman/src/Heffman.cpp

核心职责: 统计字频率、生成Huffman树、编码、解码、序列化树

数据结构:
  treeroot - Huffman树根节点指针 (Hefftreenode*)
  hashtab - 哈希表, key=字节值(0-255), value=频率和编码信息
  thread_tabs - 线程级哈希表列表
  bytecount - 处理的总字节数(64位)

压缩流程的Huffman调用序列:
  1. statistic_freq(0, dataBlock) - 统计字符频率
  2. merge_ttabs() - 合并所有线程的频率表
  3. gen_hefftree() - 构建Huffman树
  4. save_code_inTab() - 生成变长编码表
  5. tree_to_plat_uchar(huffTree) - 序列化树为字节流
  6. (循环) encode(dataBlock, compressedBlock) - 逐块编码

解压流程的Huffman调用序列:
  1. spawn_tree(huffTree) - 从字节流恢复树
  2. (循环) decode(dataBlock, decompressedBlock, BitHandler(), maxSize) - 逐块解码

statistic_freq() - 频率统计 (src/Heffman.cpp:17)
  参数: thread_id (线程编号), in_block (输入字节块)
  功能: 统计in_block中各字节的出现次数
  算法:
    对 in_block 中的每个字节c:
      threadTab[c].freq++ (频率加1)
  note: 支持多线程统计, 每个线程维护独立的frequency表

merge_ttabs() - 频率表合并 (src/Heffman.cpp:31)
  功能: 汇总所有线程的频率数据到总表hashtab
  步骤:
    1. 清空hashtab
    2. 遍历所有thread_tabs
    3. 对每个线程的频率表中的条目:
       hashtab[字符].add(频率信息)
    4. 清空所有thread_tabs

gen_minheap() - 小顶堆生成 (src/Heffman.cpp:53)
  功能: 为树生成算法准备数据
  过程:
    对 hashtab 中的每个(字符, 频率)对:
      1. 创建叶节点: new Hefftreenode(字符, 频率, true)
      2. 将节点压入小顶堆
  结果: 返回包含所有叶节点的小顶堆

gen_hefftree() - Huffman树生成 (src/Heffman.cpp:62)
  经典Huffman算法实现:
    1. 清空旧树
    2. 获取小顶堆
    3. 当堆大小 > 1:
       a. 取出频率最小的两个节点: left, right
       b. 创建父节点: parent = new Hefftreenode(频率=left.freq+right.freq, left, right)
       c. 将parent压入堆
    4. 堆最后剩余的唯一节点即为树根 treeroot
  性质: 构建的树是最优前缀码树

save_code_inTab() - 编码表生成 (include/Heffman.h:51)
  功能: 为各字符分配可变长二进制编码
  方法: 递归调用 run_save_code_inTab(treeroot)
  编码方案:
    - 从根遍历到叶子的路径: 左子树=0, 右子树=1
    - 路径即为该字符的编码
    - 频率高的字符编码短, 频率低的字符编码长

tree_to_plat_uchar() - 树序列化 (include/Heffman.h:53)
  功能: 将Huffman树转换为字节流, 便于存储和传输
  输出: out_block (字节向量)
  编码方案: (具体编码格式依实现细节)
    - 采用前序/中序/后序遍历之一记录树结构
    - 记录每个叶节点的字符值和频率
    - 可用于解压侧恢复同一棵树

spawn_tree() - 树反序列化 (include/Heffman.h:55)
  功能: 从tree_to_plat_uchar()的输出恢复树
  输入: in_block (序列化的树字节流)
  结果: treeroot被重构, 与压缩时的树相同

encode() - 数据编码 (include/Heffman.h:47)
  参数:
    in_block - 原始数据块
    out_block - 编码后的数据块(输出)
    BitHandler - 比特处理器(默认)
  功能: 将in_block中的每个字节转换为可变长二进制编码
  算法:
    对 in_block 中的每个字节:
      1. 在hashtab中查找对应的编码
      2. 将编码写入比特缓冲
      3. 当缓冲满8位时输出一个字节到out_block
  结果: out_block通常比in_block短(压缩率取决于字频分布)

decode() - 数据解码 (include/Heffman.h:48)
  参数:
    in_block - 编码的数据块
    out_block - 解码后的数据块(输出)
    BitHandler - 比特处理器
    maxOutputSize - 最大解码字节数(限制输出)
  功能: 将编码数据还原为原始字符
  算法:
    1. 当前指针初始化为treeroot
    2. 对 in_block 的每个比特:
       a. 若比特==0则向左走, 若比特==1则向右走
       b. 若到达叶节点: 输出该节点的字符, 指针复位为treeroot
    3. 输出字符数达maxOutputSize时停止
  note: 每个字节块使用独立的树(压缩时每块前都写入树), 解压时需要先恢复树后解码

【Huffman优化】
  - 每个BUFFER_SIZE字节块使用独立的Huffman树, 避免单块过大导致树不优化
  - 树被序列化并加密后存储在压缩数据中, 解压时先读树再解码
  - 多线程支持: 可并行统计多个数据块的字频率, 最后合并(提升大文件性能)


                    AES加密算法实现

Aes类
文件位置: EncryptionModules/Aes/include/My_Aes.h
         EncryptionModules/Aes/src/AesFunctions.cpp
         EncryptionModules/Aes/src/mainCircle.cpp

标准: AES-128(128位密钥, 10轮加密)

构造函数
  参数: aes_key - 用户输入的密钥字符串(任意长度)
  初始化:
    1. 调用 hash_to_16bytes() 将密钥哈希到128位(16字节)
    2. 调用 extendKey() 从128位密钥生成44个32位密钥字(round keys)
    3. 初始化IV为全0

主接口函数

doAes() - 统一加密/解密接口
  参数:
    mode - 1表示加密, 2表示解密
    inputBuffer - 输入数据块
    outputBuffer - 输出数据块(自动分配大小)
  调用:
    mode==1: 调用aes()进行加密
    mode==2: 调用deAes()进行解密

hash_to_16bytes() - 密钥哈希 (My_Aes.h:37)
  功能: 将任意长度的密钥转换为16字节
  方法: 使用SHA-256然后截取前16字节
  实现: 调用OpenSSL的SHA_256库函数

key_expansion() - 密钥扩展
  输入: 16字节主密钥
  输出: 44个32位的round keys (w[0]到w[43])
  算法:
    1. 前4个words直接来自主密钥 (w[0]-w[3])
    2. 对i=4到43:
       若 i % 4 == 0:
         w[i] = w[i-4] XOR T(w[i-1])
         其中T()函数包含RotWord、SubWord、Rcon异或运算
       否则:
         w[i] = w[i-4] XOR w[i-1]
  结果: 用于10轮加密循环的round keys

加密过程 aes() (mainCircle.cpp)
  输入: 16字节的明文块 p[16]
  步骤:
    1. AddRoundKey(初始轮, round=0)
       与w[0]-w[3]进行XOR
    2. 9轮加密循环(round=1到9):
       SubBytes() - S盒替换
         对每个字节: S[高4位][低4位] -> 替换后的字节
         S盒: 标准AES S盒(256个值的替换表)
       ShiftRows() - 行移位
         行0: 不移位
         行1: 左移1位
         行2: 左移2位
         行3: 左移3位
       MixColumns() - 列混淆
         每列4个字节与矩阵相乘(在GF(2^8)域):
         [2 3 1 1] [b0]   [r0]
         [1 2 3 1] [b1] = [r1]
         [1 1 2 3] [b2]   [r2]
         [3 1 1 2] [b3]   [r3]
         使用预计算的查表GF_MUL_2、GF_MUL_3优化
       AddRoundKey(round=1-9)
         与当前轮的round key进行XOR
    3. 最后一轮(round=10):
       SubBytes()
       ShiftRows()
       AddRoundKey(round=10)
       (注意: 最后一轮不做MixColumns)
  输出: 16字节的密文

解密过程 deAes() (mainCircle.cpp)
  逆向过程: 调用逆运算替换前面的4个操作
  步骤:
    1. AddRoundKey(round=10)
    2. 9轮解密循环(round=9到1):
       InvShiftRows() - 行右移
       InvSubBytes() - 逆S盒替换(使用S2盒)
       AddRoundKey(round)
       InvMixColumns() - 逆列混淆
         使用矩阵的逆矩阵:
         [0xe 0xb 0xd 0x9] [c0]   [b0]
         [0x9 0xe 0xb 0xd] [c1] = [b1]
         [0xd 0x9 0xe 0xb] [c2]   [b2]
         [0xb 0xd 0x9 0xe] [c3]   [b3]
    3. InvShiftRows()
       InvSubBytes()
       AddRoundKey(round=0)
  输出: 16字节的明文

【核心操作详解】

SubBytes() - 字节替换 (AesFunctions.cpp)
  实现:
    int index = (高4位 << 4) | 低4位
    result = S[index/16][index%16]
  特点: 线性独立、提供混淆性质

ShiftRows() - 行位移 (AesFunctions.cpp)
  操作矩阵(按列存储):
    state[0][0] state[0][1] state[0][2] state[0][3]  - 不动
    state[1][1] state[1][2] state[1][3] state[1][0]  - 循环左移1
    state[2][2] state[2][3] state[2][0] state[2][1]  - 循环左移2
    state[3][3] state[3][0] state[3][1] state[3][2]  - 循环左移3
  目的: 破坏列相关性

MixColumns() - 列混淆 (AesFunctions.cpp)
  对每列应用线性变换:
    使用GF(2^8)上的乘法(Galois Field)
    预计算表: GF_MUL_2[256], GF_MUL_3[256]
    通过表查询而非实际计算, 大幅提升速度
  目的: 增强扩散性质

AddRoundKey() - 轮密钥加 (AesFunctions.cpp)
  操作: state[i][j] ^= w[round*4 + (i+j*4)%4]
  特点: 简单的XOR操作, 唯一涉及round key的步骤

getNumFromSBox() / getNumFromS1Box()
  使用S盒或其逆盒进行替换
  S盒(S[16][16]): 加密使用
  S1盒(S2[16][16]): 解密使用

leftLoop4int() / rightLoop4int()
  旋转操作: 用于RotWord(密钥扩展中的字旋转)
  leftLoop4int(array, 1): 左旋1位

T()函数 (AesFunctions.cpp:75)
  在密钥扩展中使用
  步骤:
    1. 将32位数分成4个字节
    2. RotWord: 旋转这4个字节
    3. SubWord: 对每个字节进行S盒替换
    4. 结果与Rcon[round]进行XOR
  目的: 依赖混淆和扩展密钥变化

【加密流程集成】

压缩中的加密:
  1. CompressionLoop::compressionLoop() 中:
     a. 对Huffman树进行序列化得到 huffTree (DataBlock)
     b. 调用 aes.doAes(1, huffTree, huffTree_outPut) 加密树
     c. 调用 dataExporter.exportDataToFile_Compression(huffTree_outPut) 写入
  2. 对压缩数据进行加密:
     a. Huffman编码得到 compressedData
     b. 调用 aes.doAes(1, compressedData, encryptedBlock) 加密数据
     c. 调用 dataExporter.exportDataToFile_Compression(encryptedBlock) 写入

解压中的解密:
  1. DecompressionLoop::decompressionLoop() 中:
     a. BinaryIO_Loader 读取加密的树数据块
     b. 若ivNum != 0, 调用 aes.doAes(2, rawTreeData, decryptedTreeData) 解密
     c. 调用 huffmanUnzip.spawn_tree(decryptedTreeData) 恢复树
  2. 对加密的压缩数据进行解密:
     a. 读取数据块
     b. 调用 aes.doAes(2, rawData, decryptedData) 解密
     c. 调用 huffmanUnzip.decode(decryptedData, decompressedData) 解码

【加密安全性】
  - AES-128标准实现, 128位密钥长度
  - 10轮加密, 符合标准强度
  - IV初始化为0(简化实现, 不采用CBC模式)
  - 密钥通过SHA-256哈希转换, 确保任意长度的用户输入转换为128位密钥


                          主函数和程序入口

整体架构简述:

压缩主循环:
  CompressionLoop::compressionLoop() {
    初始化 BinaryIO_Loader (读目录块)
    初始化 Heffman
    初始化 DataExporter

    while (fileQueue 非空) {
      获取待压缩文件
      初始化 DataLoader (读源文件)

      for (每个数据块) {
        dataLoader.dataLoader() - 读取BUFFER_SIZE字节
        huffmanZip.statistic_freq(0, dataBlock) - 统计字频
        huffmanZip.merge_ttabs() - 合并频率表
        huffmanZip.gen_hefftree() - 构建树
        huffmanZip.save_code_inTab() - 生成编码表
        huffmanZip.tree_to_plat_uchar(huffTree) - 序列化树
        aes.doAes(1, huffTree, encryptedTree) - 加密树
        dataExporter.exportDataToFile_Compression(encryptedTree) - 写入树

        huffmanZip.encode(dataBlock, compressedData) - 压缩数据
        aes.doAes(1, compressedData, encryptedBlock) - 加密数据
        dataExporter.exportDataToFile_Compression(encryptedBlock) - 写入数据
      }

      dataExporter.thisFileIsDone(offsetToFill) - 回填压缩大小
    }

    headerLoaderIterator.encryptHeaderBlock(aes) - 加密并回填目录块
  }

解压主循环:
  DecompressionLoop::decompressionLoop() {
    初始化 BinaryIO_Loader (读目录块)
    初始化 Heffman

    while (directoryQueue 非空 或 fileQueue 非空) {
      createDirectory() - 创建所有待恢复目录

      while (fileQueue 非空) {
        打开输出文件
        初始化 DataExporter (写解压数据)

        while (该文件数据未读完) {
          读取加密树数据块
          aes.doAes(2, encryptedTree, huffTree) - 解密树
          huffmanUnzip.spawn_tree(huffTree) - 恢复树

          读取加密数据块
          aes.doAes(2, encryptedData, compressedData) - 解密数据
          huffmanUnzip.decode(compressedData, decompressedData) - 解压数据
          dataExporter.exportDataToFile_Decompression(decompressedData) - 写入文件
        }
      }

      若队列未空则请求下一轮读取
    }
  }


核心数据流动:

压缩:
  用户源文件
    |
    v
  DataLoader::dataLoader()
    |
    v
  BUFFER_SIZE字节块
    |
    v
  Heffman::statistic_freq/merge/gen_hefftree/save_code/encode
    |
    v
  树(序列化) + 压缩数据
    |
    v
  Aes::doAes(mode=1)
    |
    v
  加密后的树 + 加密后的数据
    |
    v
  DataExporter::exportDataToFile_Compression()
    |
    v
  .sy文件 (结构: [header] [目录块] [加密树块] [加密数据块] [加密树块] ...)

解压:
  .sy文件
    |
    v
  BinaryIO_Loader::loadBySepratedFlag()
    |
    v
  加密后的树 + 加密后的数据
    |
    v
  Aes::doAes(mode=2)
    |
    v
  树 + 压缩数据
    |
    v
  Heffman::spawn_tree/decode
    |
    v
  BUFFER_SIZE字节块(解压后)
    |
    v
  DataExporter::exportDataToFile_Decompression()
    |
    v
  恢复的源文件


                    关键常量和数据类型定义

缓冲和偏移常量:
  BUFFER_SIZE = 65536 (字节) - 单次处理的数据块大小
  SEPARATED_STANDARD_SIZE = FLAG_SIZE + sizeof(DirectoryOffsetSize_uint) + sizeof(IvSize_uint)
  HEADER_SIZE = 11 (字节) - 文件头大小(包括第一个魔数)
  MAGIC_NUM = 0xDEADBEEF (4字节) - 文件标记

类型定义:
  DataBlock = std::vector<uint8_t> - 数据块向量
  Directory_FileQueue = std::queue<{Directory_FileDetails, uint64_t}> - 目录或文件队列
  Heffmap = std::unordered_map<unsigned char, FreqInfo> - 字节频率哈希表
  Hefftreenode - Huffman树节点结构体

标志字节:
  FILE_FLAG = 'F' (0x46) - 文件标识
  DIRECTORY_FLAG = 'D' (0x44) - 目录标识
  SYMBOL_LINK_FLAG = 'L' (0x4C) - 符号链接标识
  LOGICAL_ROOT_FLAG = 'R' (0x52) - 逻辑根标识
  SEPARATED_FLAG = 'S' (0x53) - 分割块标识

