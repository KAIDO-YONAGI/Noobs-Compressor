# 目录

- [目录](#目录)
- [1. 用户视角的应用](#1-用户视角的应用)
- [2. 程序概览](#2-程序概览)
- [3. 程序结构初步设计](#3-程序结构初步设计)
  - [3.1 程序结构及要点](#31-程序结构及要点)
  - [3.2 初步设计](#32-初步设计)
- [4. 底层细节与技术](#4-底层细节与技术)
  - [4.1 技术整合与分析](#41-技术整合与分析)
  - [4.2 关键技术点](#42-关键技术点)
- [5. 算法具体实现](#5-算法具体实现)
  - [5.1 实现方案](#51-实现方案)
  - [5.2 疑难问题的解决方案](#52-疑难问题的解决方案)
  - [5.3 优化与改进](#53-优化与改进)
- [6. 安全问题](#6-安全问题)
  - [6.1 Aes 的安全性问题](#61-aes-的安全性问题)
  - [6.2 数据完整性问题](#62-数据完整性问题)
  - [6.3 系统安全考虑](#63-系统安全考虑)
- [7. 最终实现](#7-最终实现)
  - [7.1 程序的运行流程](#71-程序的运行流程)
- [流程图](#流程图)
  - [SFC 数据流图](#sfc-数据流图)
  - [SFC 结构图](#sfc-结构图)
  - [SFC 流程图](#sfc-流程图)

# 1. 用户视角的应用

> 应用需要什么功能？

我们需要尽可能给用户提供自由的压缩选项。

【问题 A1】  
是否需要加密？用什么算法加密？这在 GUI 界面中分别通过一个勾选器和列表选择器让用户操作。

【问题 A2】  
在压缩时，可能需要处理多个文件一起压缩的情况。将多个文件整合成一个压缩包？所有文件分别独立成一个压缩包？或是在应用内可选择分类生成多个压缩包？需要提供一个选项供用户选择。

【问题 A3】  
~~对于编码结构，用户可以选择是否将其独立成一个文件存放。~~（已不纳入考虑）

【问题 A4】  
使用 RSA 加密可以实现特定用户间的数据加密传输。这时需要提供一个 RSA 密钥生成器。

【问题 A4】  
可以选择从右键菜单栏中直接启动压缩任务。

# 2. 程序概览

-
- **AES 加密**：高级加密标准，高级加密标准对称性加密算法。
- **RSA 加密**：非对称性加密算法。（备选）
- **流加密**：逐字节加密处理。（备选）
- **Huffman 编码**：基于前缀码的无损压缩算法。
- **BWT 编码**：基于后缀数组的压缩数据预处理算法。（备选）
- **lz77**:使用滑动窗口建立三元组的压缩算法，可作为 Huffman 压缩的前置操作
- **Qt**：c++的 GUI 框架，跨平台兼容。
- **文件头**：包含压缩文件基本信息的数据结构。
- **位图(bitmap)**：按位存储状态。
- **信号与槽**：Qt 框架的核心思想，响应式 GUI 编程。
- **锁**：控制临界区的变量，持有锁的线程可以进入临界区。
- **条件变量**：核心为休眠队列，通过信号唤醒队列中的线程。
- **信号量**：类似 Minecraft 的红石比较器，或 AE 的发信器。控制进入临界区线程的数量。
- **死锁**：多个线程争抢锁的形式构成单向环图的状况。造成线程永久的休眠。
- **系统调用**：由操作系统提供给应用程序的接口。通常是受限操作，由操作系统执行。

# 3. 程序结构初步设计

## 3.1 程序结构及要点

**Compress/Decompress_System**

- 负责压缩与解压。

**Encryption/Decryption_System**

- 负责加密与解密工作。

**BufferPool**

- 缓存以上两者的输出（通信缓存池、打包缓存池、解包缓存池）
- 充当可接受线程管理器动态调度的对象
- 每个线程组独立使用一个缓存池
- 加入大小限制和溢出处理机制
- 充当接收输入并缓存/主动抛出的作用

**ErrorCollector**

- 负责对错误的检测与收集，生成并且输出相关错误报告(日志)

## 3.2 初步设计

**Encryption**  
 技术点(适配技术)：

1. 密钥 hash 处理
2. 尾部补全与去除（aes 需要内置）
3. 缓存池

**Compression**

1. 继承一个缓存池接口，以二进制抛出数据块
2. (待补充)
3. (待补充)

**UnitManager**

- 示意：Huffman-(1)>Aes-(2)>.sy 文件(实际为二进制)
- 虚拟接口类的设计：

**BufferPool**

- **依赖以下四种缓存方案实现程序的几乎所有数据流通：**

  1. 通信缓存池：压缩与加密端之间的通信。

  2. 打包缓存池：打包压缩单独输出、压缩加密输出（利用文件头区分。可能分别设计两类接口）

  3. 解包缓存池：直接由 UnitManager 控制目录的收发，打包时将目录存放到文件头，配合文件分割标志（是一个经过读取缓存池方法转换后，赋给数据块对象的变量的 bool 类型变量值）来用于此处的目录还原。

  4. 读取缓存池：读取目录并传输至打包缓存池。读取文件后：为压缩模块发送数据块、为解压模块发送数据。
     使用四个字节的滑动窗口动态检测魔数，遇到魔数则更改操作状态（要求魔数总是成对出现）

**文件**

1. 状态检测器：检测加密状态（Y/N）。监控文件压缩进度。

2. 文件信息读取器：将文件的整个文件头读取到程序缓存中，并进行相关检查。监控文件解压进度。

- 关于数据块类：

```
  vector<uint8_t> data    // 数据（二进制），可以先给定一个基础大小，避免频繁扩容
  uint32_t sequence_tag   // 顺序标签
  bool is_terminated      // 终止信号
  uint8_t header_flags    // 文件头标志位
  string source_tag       // 来源标签（如"COMPRESS", "AES"）
  string error_message    // 错误信息
```

- **偏移量记录方式和相关规则**

  - 维护：在文件头中存储数据文件的文件名初始大小，解压时逐步递减，直至字节数不足。
  - 另外，需要在压缩时动态维护已压缩文件的大小，待数据块抛出进程结束信号时写入文件头中预留好的偏移量的数据上，可以用于多文件下的 huffman 与 aes 的部分功能实现

**GUI**

1. 多线程模式选择(后续自动检测)
2. 加密、压缩算法切换
3. 引入已加密的标记与加密文件的自动识别、提示输入密码
4. 询问用户是否替换（跳过）冲突文件

**Optimization**  
优化：

- **Aes**
  1. 多线程：可能使用文件分割，需要注意内存和线程数检测
  2. 需要引入 id 标记分块文件，以便整合为文件输出
  3. 指令集加速(aes 提速、huffman 提速、LZ77 提速)
- **Huffman**
  1. 多线程，部分同 Aes
- **BufferPool**
  1. 多线程流水线
  2. 防溢出
- **ThreadManager**
  - 管理模块（分割文件并分配，需要传输各自的组合顺序标签）
  - 后续会拥有独立的多线程打包缓存池，负责打包各个打包缓存池的数据
  - 多线程流水线：具体来说 使用一一对应的生产者-消费者构建数个流水线，并且运用双缓冲技术赋予上下游异步读写的能力，实现提速和上下游模块的解耦。 可以多线程地使用多条流水线。（后续可以使用环形缓冲区进一步优化上下游之间的数据流）

# 4. 底层细节与技术

## 4.1 技术整合与分析

主要技术：

- **加密：**
  - aes-128
- **压缩：**
  - huffman
- **控制：**
  - thread/buffer
- **文件**
  - .sy
    分析：
- **加密：**
  - aes-128：128bit 密钥，十轮处理。
- **压缩：**
  - huffman：基于自然语言重复性的压缩算法
- **控制：**
  - thread/buffer:
    - 线程与线程、模块与缓存池之间的组合与调度
- **文件**

```

      -------Magic------4B
      [文件头]
      ├─[Flags]  |1B压缩方案||1B软件版本号|
      |          └─程序存储一个方案表，不同方案在此处对应一定的数值
      |
      ├─[文件头偏移量1B][目录表偏移量4B]
      └─------Magic------

      [目录信息]
      ├─ |偏移量|
      │  |目录块|
      ├─ |偏移量|
      │  |目录块|
      └─------Magic------

      [数据区]
      ├─ |偏移量|
      │  |数据块|
      │ 
      ├─ |偏移量|
      |  |数据块|
      └─------Magic------
```

- 可借鉴 7z：

```
      [ 文件头 (固定16字节) ]
      ├─ Magic:         0x2E 0x73 0x79 0x1A (".sy\x1A")
      ├─ Version:       0x01 0x00 (小端)
      ├─ Flags:         0xC5 (二进制 11000101)
      │                  11000101
      │                  ││││││└─ 保留位
      │                  │││││└── 含文件属性
      │                  ││││└─── 含时间戳
      │                  │││└──── 分块文件
      │                  ││└───── 多文件包
      │                  │└────── 使用压缩
      │                  └─────── 已加密
      └─ Header CRC:    0x78 0x56 0x34 0x12

      [ 扩展头（可变长度） ]
      ├─ [压缩头]
      │  ├─ AlgorithmID: 0x01 (Huffman=0x01,LZMA=0x02)
      │  └─ DictSize:    0x00 0x40 0x00 0x00 (16MB)
      │
      ├─ [加密头]
      │  ├─ Method:      0x02 (AES-256-CBC)
      │  ├─ KDFIterLog:  0x10 (迭代次数=2^16)
      │  ├─ SaltSize:    0x10
      │  └─ Salt:        16字节随机值
      │
      ├─ [文件清单]
      │  ├─ FileCount:   0x02 0x00 (2个文件)
      │  ├─ [FileMeta1]  结构体含文件名
      │  └─ [FileMeta2]
      │
      ├─ [分块信息]
      │  ├─ BlockCount:  0x03 0x00 0x00 0x00
      │  └─ BlockSizes:  [8字节×3]
      │
      └─ HeaderEndMark: 0xFF 0xFF

      [ 数据区 ]
      ├─ [块1]
      │  ├─ CompressedSize:   8字节
      │  ├─ OriginalSize:     8字节
      │  └─ Data:             N字节密文
      ├─ [块2]...
      └─ [块n]
```

## 4.2 关键技术点

- 模块间通信机制设计
- 缓冲区数据同步方案
- 加密压缩的顺序化处理
- 异常处理和恢复机制

# 5. 算法具体实现

## 5.1 实现方案

- **Aes 加密实现：**
  - PKCS#7 填充方案
  - 密钥派生函数处理用户密码
- **Huffman 压缩实现：**
  - 基于频率统计的编码
  - 并行化文件处理
- **文件头**

  - 1.
  - 记录文件头和数据块的偏移量

  - 记录压缩方案：加密方式/有无加密、压缩方式。

  - 2. 记录数据块偏移量：具体来说，这些数字应当是记录数据各个文件在'压缩文件数据区'的位置（利用文件指针能够继续读取的特性）。

  - 3. 在文件头记录文件的目录结构、偏移量：其中目录结构使用前缀索引（将会在前缀记录所有文件目录，其对应数据区存储包含文件后缀的文件名）、偏移量单独在文件名后存储（为每个节点预留 2*8 字节，分别存储文件压缩前后大小）

  - 4. 对于动态获取的偏移量的实时存储（接到结束信号后将压缩偏移量从缓冲区写入文件）。

    方案：读取文件目录之后直接在文件头中逐个处理对应文件（服务于数据偏移量更新），并且在预留好的位置修改压缩后大小。（不影响数据区写入数据。）
    ――至此，实现无临时文件的方案已经完善。

  - 5. **文件头信息写入**

    - 实现细则：

    - 1. 文件信息存储协议：|文件标|2B 文件名大小偏移量|文件名|----|

      - 文件标为字符 0：为目录。需要写入：|4B 第一级文件数量|
      - 文件标为字符 1：为文件。需要写入：|8B 原文件大小|8B 压缩后偏移位|。其中压缩大小暂时作为占位区。

      - 为加密/分块特化的标签：文件标为字符 2：为分割偏移量（下一分区）写入|32bits 偏移量||16Biv加密头|，如果读到偏移量为零，说明此时已经写入到最后一个不足8KB的块（按目录的残余偏移量来读取，包含只有一块的情况）aes的加密头会写入到预留位置
  - 2. 压缩前运行：

    - 0. 文件头开始与结束均需要写入魔数。

    - 1. 目录：读取后写入对应的存储协议，并且在缓冲区中缓存一个文件数量。

    - 2. 文件：读取后写入对应的存储协议

    - 3. 搜索方案：采用 BFS。在上述 0、1、2 作为必要操作的条件下，搜索目录。

      I:

      - 如果搜索到文件：直接写入。
      - 如果搜索到目录：进入该目录并且记录其中第二级文件数量以及该目录的完整路径到队列备用。并且按协议写入文件。

      II:记录完数量后：返回，继续搜索第一级目录,重复操作 I,直到第一级搜索完成。

      III:处理队列，接着按照队列已存储的路径打开下一级目录，以先前获取的第二级文件数量及其所在目录的路径，按顺序读写对应的文件数据，直至文件数量 num--耗尽为止。

      IV：重复上述操作直到读取完成。

      以上 I~III 解决了解压文件时如何按照顺序读取文件及其目录的问题。

      V:特别地，可以为目标文件提供一个逻辑根目录（同名或命名），以便始终遵循如上顺序读写数据（或者单独存储根目录下的子文件/目录数量）。

      VI:文件头开始为写入文件头偏移量预留位置，文件头写入完毕后更新这个偏移量

      VII:如果需要加密，则按照偏移量在原内容上进行覆写

  tips： 偏移量的读取和使用：

  - 使用<fstream>的 tellg()、tellp() / seekg()、seekp()。
    具体来说：

    - 在接到该文件读取完成信号之后，需要在文件头对应的偏移回填大小。

- **文件头信息获取**
  1. 通用部分：
     - I: 打开文件直接读取魔数，并且按照文件头方案读取策略等数据，如文件头以及文件目录的偏移量
     - II: 定位到文件目录起始位置，根据分隔符将文件目录信息按块读进内存中处理
     - III: 读取完 文件信息/压缩后数据 之后，记录此处的偏移量以便下一次处理时直接定位
  2. 压缩时的信息获取：
     - 在完成通用部分的基础上：
     - 需要获取并且拼接文件的路径，通过某种传输方式发送给压缩模块处理。
     - 需要在获取到数据块结束标志时写入末尾偏移量（统一以当前文件大小存储，并且在循环中更新下一次起始位置为上一次末尾偏移量）
     - 加密时确保数据块一次性处理完之后再交予写入程序写入文件中，预计更换aes为cfb模式的实现
  3. 普通解压时的信息获取：
     - 在完成通用部分的基础上：
     - I:对于文件：获取其在数据区的偏移量并且定位到数据区对应的位置读取数据（注意按最小 16 字节整块读取）
     - II:对于文件夹：获取它携带的子文件数量信息并且记录到“下一层文件数量”，同时创建文件夹以及其 details 信息类对象，并将对象存入到队列中备用
     - III:按照以上方式读取数据直到耗尽本层的“文件数量”（根目录以及多文件根目录的边界情况：使用了加入逻辑根节点的方式解决）
     - IV:循环以上操作，并且注意比对此时的读取位置与文件头中记录的文件目录偏移量。
  4. 解压时数据获取：
     - 对于被加密的数据块：按偏移量分割，分块读取数据，解密后存储在内存中（需要专门编写一种新的读取函数，不过逻辑是类似的）
     - 加密后的目录需要被读取到内存后经过解密处理传回文件处理模块使用
     - 内存中保留拼接好的路径，抛弃已处理完的文件目录数据（动态数组采用默认 9KB 大小，实际上最多只能读到 8KB+600B 左右,配合 clear 恢复 size=0）

## 5.2 疑难问题的解决方案

- 加密压缩顺序问题：
  - 采用先压缩后加密的标准流程
- 大数据处理：
  - 引入分块处理机制
- 性能瓶颈：
  - 动态调整线程池大小
- 内存管理：
  - 限制缓冲区最大尺寸

## 5.3 优化与改进

- **性能优化：**
  - SIMD 指令加速
- **功能扩展：**
  - 支持多种加密算法
  - 增加压缩算法选择
- **用户体验：**
  - 进度显示优化
  - 错误信息友好化

# 6. 安全问题

## 6.1 Aes 的安全性问题

- 密钥管理方案设计
- 加密模式选择分析

## 6.2 数据完整性问题

- 校验和机制
- 防篡改设计

## 6.3 系统安全考虑

- 内存敏感数据清理
- 临时文件安全处理
- 权限最小化原则

# 7. 最终实现

## 7.1 程序的运行流程

1. 用户通过 GUI 选择操作模式(加密/解密、压缩/解压)
2. 选择输入文件和输出路径
3. 输入必要参数(如密码)
4. UnitManager 初始化处理模块
5. 文件分块进入处理流水线
6. 加密/压缩顺序处理
7. 结果写入输出文件
8. 错误处理和日志记录
9. 内存清理和资源释放

# 流程图

## SFC 数据流图

![alt text](FlowCharts/项目分析DFD1.png)

## SFC 结构图

![alt text](FlowCharts/SFC结构图.png)

## SFC 流程图

- 配置模块
  ![alt text](FlowCharts/配置模块流程图.png)
- 压缩模块
  ![alt text](FlowCharts/压缩模块流程图.png)
- 解压模块
  ![alt text](FlowCharts/解压模块流程图.png)
