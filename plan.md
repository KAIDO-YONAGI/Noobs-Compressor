# 加密与压缩

## 目录
1. [用户视角的应用](#1-用户视角的应用)
2. [程序概览](#2-程序概览)
3. [程序结构初步设计](#3-程序结构初步设计)
   - [3.1 程序结构及要点](#31-程序结构及要点)
   - [3.2 初步设计](#32-初步设计)
4. [底层细节与技术](#4-底层细节与技术)
   - [4.1 技术整合与分析](#41-技术整合与分析)
   - [4.2 关键技术点](#42-关键技术点)
5. [算法具体实现](#5-算法具体实现)
   - [5.1 实现方案](#51-实现方案)
   - [5.2 疑难问题的解决方案](#52-疑难问题的解决方案)
   - [5.3 优化与改进](#53-优化与改进)
6. [安全问题](#6-安全问题)
   - [6.1 Aes的安全性问题](#61-aes的安全性问题)
   - [6.2 数据完整性问题](#62-数据完整性问题)
   - [6.3 系统安全考虑](#63-系统安全考虑)
7. [最终实现](#7-最终实现)
   - [7.1 程序的运行流程](#71-程序的运行流程)

## 1. 用户视角的应用
- 见"策划.md"

## 2. 程序概览
- 见"策划.md"

## 3. 程序结构初步设计

### 3.1 程序结构及要点

**Encryption/Decryption_System**  
负责加密与解密工作，与压缩端以二进制数据进行通信。  
需要打包为线程。

**Compress/Decompress_System**  
负责压缩与解压。  
需要打包为线程。

**BufferPool**  
- 缓存以上两者的输出
- 充当可接受线程动态调度的对象
- 每个线程组独立使用一个缓存池
- 加入大小限制和溢出处理机制
- 仅充当被调度对象

**ThreadManager**  
- 负责在线程尺度下调度一级线程
- 若引入多线程，需要管理二级线程
- 优先级和资源分配策略

**ErrorCollector**  
负责对错误的检测与收集，生成并且输出相关错误报告(日志)

### 3.2 初步设计

**Aes**  
技术点(适配技术)：
1. 密钥hash处理
2. 尾部补全与去除
3. 缓存池
(全部已完成)

**Heffman**  
1. 希望所有即将引入的压缩算法能整合多文件为单文件并输出
2. (待补充)
3. (待补充)

**Combination**  
示意：Heffman-(1)>Aes-(2)>.sy文件(实际为二进制)

1. 单流程：模块化的独立线程处理
   - **I:线程管理**
     * 将heffman与aes作为单独线程
     * 使用无锁队列或批量传输减少同步开销
     * 可优化：按照算法耗时管理线程并行数量
   - **II:io**
     * 从缓冲池接收压缩端的输出，加密
   - **III:方案的优点**
     * 支持未来的新增算法
     * 处理流程的高度可定义性
   - **IV:面临的问题**
     * 需缓冲区管理、线程同步、流量控制
     * 缓冲区可能成为性能瓶颈
     * 需处理跨线程异常和状态一致性

2. 多线程的管理
   - **I:文件分割的管理方法**
     * 加密结束后依据预先传输的顺序表整合加密后的结果
   - **II:** (待补充)

**GUI**  
设计GUI：
- I：多线程模式选择(后续自动检测)
- II：加密、压缩算法切换
- III：引入已加密的标记与加密文件的自动识别、提示输入密码

**Optimization**  
优化：
- **Aes：**
  * I：多线程：可能使用文件分割，需要注意内存和线程数检测
  * II：需要引入id标记分块文件，以便整合为文件输出
  * III：指令集加速(十倍aes提速)
- **Heffman：**
  * I：多线程，部分同Aes
- **Combination：**
  * I：串行多线程(多级线程)
  * II：线程安全

## 4. 底层细节与技术

### 4.1 技术整合与分析
主要技术：
- **加密：**
  * aes-128
- **压缩：**
  * heffman
- **控制：**
  * thread/buffer

分析：
- **加密：**
  * aes-128：128bit密钥，十轮处理，足以应对大多数传统攻击
- **压缩：**
  * heffman基于自然语言重复性的压缩算法
- **控制：**
  * thread/buffer:
    - 线程与线程、线程与缓存池之间的组合与调度
    - 难点在于ThreadManager的实现
      + 一级线程：管理压缩/解压缩、加密/解密的主要处理线程
      + 二级线程：算法内部的并行处理线程(如文件分块处理)

### 4.2 关键技术点
- 线程间通信机制设计
- 缓冲区数据同步方案
- 加密压缩的顺序化处理
- 异常处理和恢复机制

## 5. 算法具体实现

### 5.1 实现方案
- **Aes加密实现：**
  * PKCS#7填充方案
  * 密钥派生函数处理用户密码
- **Heffman压缩实现：**
  * 基于频率统计的编码
  * 并行化文件处理
- **线程控制方案**
## 线程封装与线程/缓存池调度设计

### 线程封装实现方案

#### 1. 线程基础架构设计
线程封装的核心目标是将复杂的线程管理抽象化，提供简洁的使用接口，同时保持高效的执行能力。我们采用分层设计：

- **应用层接口**  
  提供简单的任务提交API，隐藏底层线程实现细节
- **管理层**  
  处理线程生命周期、资源分配和异常捕获
- **执行层**  
  实际执行任务的线程实体

**关键设计考量**：
- 统一的任务提交接口
- 透明的异常传递机制
- 灵活的资源控制策略
- 完善的线程状态监控

#### 2. 线程生命周期管理
设计状态机模型控制线程的完整生命周期：

##### 创建阶段
- 延迟初始化：只有当任务提交时才实际创建线程
- 参数预验证：在执行前检查所有必需参数
- 资源预留：预先分配必要的系统资源

##### 执行阶段
- 心跳检测：定期报告线程存活状态
- 进度反馈：提供任务执行百分比
- 资源监控：实时跟踪CPU/内存使用

##### 终止阶段
- 优雅退出：支持平滑终止请求
- 资源回收：确保所有分配资源被释放
- 状态持久化：保存必要执行结果

#### 3. 异常处理机制
设计多层次的异常处理体系：
1. 任务级别捕获：每个任务自带异常处理器
2. 线程级别保护：防止单个任务崩溃影响整个线程
3. 系统级恢复：关键线程崩溃后的自动重启
4. 错误传播通道：将异常信息传递给错误收集器

#### 4. 线程通信设计
实现高效的线程间通信机制：
- 消息队列：基于生产者-消费者模型的异步通信
- 事件通知：使用条件变量实现等待/通知机制
- 共享内存：对于大数据量采用零拷贝传输
- 状态标志：原子操作实现的无锁状态检查

---

### 线程与缓存池之间的调度实现

#### 1. 调度系统整体架构
设计三级调度体系：

##### 战略级调度
- 决定整体资源分配策略
- 平衡加密/压缩模块的资源占比
- 根据系统负载动态调整

##### 战术级调度
- 管理单个处理管道的线程配比
- 控制批次处理的大小
- 处理缓冲区的状态平衡

##### 操作级调度
- 实现具体的任务派发
- 处理即时的资源争用
- 执行细粒度的负载均衡

#### 2. 缓存池调度策略
##### 写入策略
- 批量写入：积累一定数据量后批量提交
- 动态分块：根据负载自动调整块大小
- 优先级控制：紧急数据可以优先处理

##### 读取策略
- 预读取：提前加载预期需要的数据
- 缓存亲和性：使线程尽可能访问本地缓存
- 数据局部性：保持相关数据的空间聚集

#### 3. 资源竞争管理
##### 空间竞争
- 动态配额分配
- 分级存储策略（热/温/冷数据）
- 溢出处理机制（磁盘交换）

##### 时间竞争
- 时间片轮转调度
- 基于优先级的抢占
- 公平性保障算法

##### 数据竞争
- 乐观并发控制
- 细粒度锁策略
- 无锁数据结构应用

#### 4. 性能优化手段
##### 系统级优化
- NUMA架构感知
- CPU缓存友好设计
- 内存访问模式优化

##### 算法级优化
- 自适应批处理大小
- 动态负载平衡
- 预测性调度

##### 实现级优化
- 锁粒度精细化
- 减少伪共享
- 分支预测提示

#### 5. 死锁预防机制
构建全方位的防死锁体系：
1. 资源有序分配：定义全局资源获取顺序
2. 超时回退：设置资源获取时限
3. 死锁检测：定期运行检测算法
4 automatic recovery：发现死锁后的安全解除

#### 6. 动态调节机制
实现运行时自适应的调度策略：
1. 负载监控：实时跟踪系统指标
2. 策略评估：计算当前调度效率
3. 参数调整：动态修改调度参数
4. 效果反馈：形成控制闭环

#### 5.2 疑难问题的解决方案
- 加密压缩顺序问题：
  * 采用先压缩后加密的标准流程
- 大数据处理：
  * 引入分块处理机制
- 性能瓶颈：
  * 动态调整线程池大小
- 内存管理：
  * 限制缓冲区最大尺寸

#### 5.3 优化与改进
- **性能优化：**
  * SIMD指令加速AES
- **功能扩展：**
  * 支持多种加密算法
  * 增加压缩算法选择
- **用户体验：**
  * 进度显示优化
  * 错误信息友好化

## 6. 安全问题

### 6.1 Aes的安全性问题
- 密钥管理方案设计
- 加密模式选择分析

### 6.2 数据完整性问题
- 校验和机制
- 防篡改设计

### 6.3 系统安全考虑
- 内存敏感数据清理
- 临时文件安全处理
- 权限最小化原则

## 7. 最终实现

### 7.1 程序的运行流程
1. 用户通过GUI选择操作模式(加密/解密、压缩/解压)
2. 选择输入文件和输出路径
3. 输入必要参数(如密码)
4. ThreadManager初始化处理线程
5. 文件分块进入处理流水线
6. 加密/压缩顺序处理
7. 结果写入输出文件
8. 错误处理和日志记录
9. 内存清理和资源释放
